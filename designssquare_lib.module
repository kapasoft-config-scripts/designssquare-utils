<?php

//to include artifacts from theme scope
//i.e._theme_include('bazar','/includes/template_api.inc');
function theme_include($theme, $path) {
    static $themes = array();
    if (!isset($themes[$theme])) {
        $themes[$theme] = drupal_get_path('theme', $theme);
    }
    if ($themes[$theme] && ($file = DRUPAL_ROOT . '/' . $themes[$theme] . '/' . $path) && file_exists($file)) {
        include_once $file;
    }
}


function get_field_name_from_vocabulary($vocabulary_name, $entity_type = NULL){
    foreach (field_info_fields() as $field_name => $field) {
        if ($field['type'] == "taxonomy_term_reference" && $field['settings']['allowed_values'][0]['vocabulary'] == $vocabulary_name) {
            // Add this field to the return array if no entity type was specified or
            // if the specified type exists in the field's bundles array.
//            if (empty($entity_type) || in_array($entity_type, array_keys($field['bundles']))) {
//                $fields[$field_name] = $field;
//            }
            return $field_name;
        }
    }

}

function get_referencing_product_display_id($product) {
    global $language;

    if(isset($product->display_id)){
        return $product->display_id;
    }else{
        // Iterate through fields which refer to products.
        foreach (commerce_info_fields('commerce_product_reference') as $field) {
            // Build query.
            $query = new EntityFieldQuery;
            $query->entityCondition('entity_type', 'node', '=')
                ->fieldCondition($field['field_name'], 'product_id', $product->product_id, '=')
//            ->propertyCondition('language', $language->language, '=')
                ->range(0, 1);

            if ($result = $query->execute()) {
                // Return node id.
                $node = $result['node'];
                $node_keys = array_keys($node);
                return array_shift($node_keys);
            }
        }
    }

    return false;
}

//includes blocks in current scope(i.e html, node,etc) and places them in $region['block_id'] variable
function include_blocks(&$vars){
    $all_blocks = array();
    //making blocks available
    //retrieve context plugin as alternative for managing blocks
    $ctx_plugin = (module_exists('context')) ? context_get_plugin('reaction', 'block') : '' ;
    foreach (system_region_list($GLOBALS['theme']) as $region_key => $region_name) {
        if(block_get_blocks_by_region($region_key)) {
            $blocks = block_get_blocks_by_region($region_key);
        }
        if(!empty($ctx_plugin)){
            $ctx_blocks = $ctx_plugin->block_get_blocks_by_region($region_key);
        }

        if(isset($ctx_blocks) && isset($blocks)) {
            //there are blocks from the context and from blocks module
            $all_blocks = array_merge($blocks, $ctx_blocks);

            //sort the blocks merged
            $all_blocks['#sorted'] = FALSE;

            //maintain weights
            foreach ($all_blocks as &$block) {
                if (isset($block['#block']->weight)) {
                    $block['#weight'] = $block['#block']->weight;
                }
            }

        }elseif(isset($ctx_blocks)){
            //there are blocks ONLY from context module
            $all_blocks = $ctx_blocks;
        }elseif(isset($blocks)){
            //there are blocks ONLY from block module
            $all_blocks = $blocks;
        }

        // Get the content for each region and add it to the $region variable
        $vars['region'][$region_key] = (isset($all_blocks) && !empty($all_blocks)) ? $all_blocks : array();
    }
}


function include_blocks_from_region($region_key, &$vars){
    $all_blocks = array();
    //making blocks available
    //retrieve context plugin as alternative for managing blocks
    $ctx_plugin = (module_exists('context')) ? context_get_plugin('reaction', 'block') : '' ;
//    foreach (system_region_list($GLOBALS['theme']) as $region_key => $region_name) {
        if(block_get_blocks_by_region($region_key)) {
            $blocks = block_get_blocks_by_region($region_key);
        }
        if(!empty($ctx_plugin)){
            $ctx_blocks = $ctx_plugin->block_get_blocks_by_region($region_key);
        }

        if(isset($ctx_blocks) && isset($blocks)) {
            //there are blocks from the context as well from blocks module
            $all_blocks = array_merge($blocks, $ctx_blocks);

            //sort the blocks merged
            $all_blocks['#sorted'] = FALSE;

            //maintain weights
            foreach ($all_blocks as &$block) {
                if (isset($block['#block']->weight)) {
                    $block['#weight'] = $block['#block']->weight;
                }
            }

        }elseif(isset($ctx_blocks)){
            $all_blocks = $ctx_blocks;
        }elseif(isset($blocks)){
            $all_blocks = $blocks;
        }

        // Get the content for each region and add it to the $region variable
        $vars['region'][$region_key] = (isset($all_blocks) && !empty($all_blocks)) ? $all_blocks : array();
//    }
}

//determines if current taxonomy term is part of commerce_product
function is_product_taxonomy(){
    if(arg(0) == 'taxonomy'){
        //taxonomy
        $tid = arg(2);
        $term = taxonomy_term_load($tid);
        //retrieve all fields and filter for the particular taxonomy loaded
        foreach (field_info_field_map() as $field_name => $field) {
            if($field['type'] == "taxonomy_term_reference" && $field_name == 'field_'.$term->vocabulary_machine_name && array_key_exists('commerce_product', $field['bundles'])){
                return true;
            }
        }
    }else{
        //not a taxonomy term
        return false;
    }
}

function get_template_path($module_name, $template_name){
    $path_to_theme_templates = path_to_theme().'/templates';
    $path_to_widget_templates = drupal_get_path('module', $module_name).'/templates';

    if(file_exists($path_to_theme_templates.'/'.$template_name.'.tpl.php')){
        return $path_to_theme_templates;
    }else{
        return $path_to_widget_templates;
    }
}

//moves blocks from one sidebar to another depending on the taxonomy specified to left, right or none
function move_blocks_for_sidebars(&$context, $term_id_of_sidebar){
    $post_sidebar = taxonomy_term_load($term_id_of_sidebar);

    if((isset($post_sidebar->name)) && ($post_sidebar->name == 'right' || $post_sidebar->name == 'left')){
        $sidebar_pos = _get_sidebar_pos($post_sidebar->name);
        foreach($context->reactions['block']['blocks'] as $key => $block){
            if($block['region'] == $sidebar_pos['from']){
                //move sidebar to another side
                $context->reactions['block']['blocks'][$key]['region'] = $sidebar_pos['to'];
            }
        }
    }elseif((isset($post_sidebar->name)) && $post_sidebar->name == 'none'){
        foreach($context->reactions['block']['blocks'] as $key => $block){
            if($block['region'] == 'sidebar_first' || $block['region'] == 'sidebar_second'){
                //remove any sidebar content
                unset($context->reactions['block']['blocks'][$key]);
            }
        }
    }
}

//retrieve currently loaded node from content cache
//@return stdClass of the Node or Null if no node set in the content cache
function get_node_from_cache(){
    //get the current content from cache
    $content = drupal_set_page_content();
    //indicate that you are not adding content but just reading it by setting static variable 'system...added' to False
    $system_main_content_added = &drupal_static('system_main_content_added');
    $system_main_content_added = FALSE;

    //retrieve current node being loaded
//    $current_node = array_slice($content['system_main']['nodes'],0,1);
    $current_node = null;
    if($content){
        //cache is set
        $node_wrap = (isset($content['nodes'])) ? array_slice($content['nodes'],0,1) : null;
        $current_node = (isset($node_wrap) && !empty($node_wrap)) ? array_values($node_wrap)[0]['#node'] : null;
    }else{
        //cache not set, lets try to load from path
        if((arg(0) == 'node') && arg(1) && is_numeric(arg(1))){
            $current_node = node_load(arg(1));
        }
    }

    return $current_node;
}